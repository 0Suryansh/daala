/*
    Daala video codec
    Copyright (C) 2006-2010 Daala project contributors

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

*/


#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <getopt.h>
#include <vorbis/vorbisenc.h>
#include "../include/daala/daalaenc.h"
#if defined(_WIN32)
# include <fcntl.h>
# include <io.h>

static double rint(double _x){
  return (int)(_x<0?_x-0.5:_x+0.5);
}
#endif



typedef struct av_input av_input;



struct av_input{
  int          has_video;
  FILE        *video_infile;
  int          video_frame_w;
  int          video_frame_h;
  int          video_pic_x;
  int          video_pic_y;
  int          video_pic_w;
  int          video_pic_h;
  int          video_fps_n;
  int          video_fps_d;
  int          video_par_n;
  int          video_par_d;
  int          video_interlacing;
  char         video_chroma_type[16];
  int          video_ncomps;
  daala_comp   video_comps[4];
  od_img       video_img;
  od_img_plane video_img_planes[4];
  int          video_cur_img;
  int          has_audio;
  FILE        *audio_infile;
  int          audio_ch;
  int          audio_hz;
};



static int y4m_parse_tags(av_input *_avin,char *_tags){
  int   got_w;
  int   got_h;
  int   got_fps;
  int   got_interlacing;
  int   got_par;
  int   got_chroma;
  int   tmp_video_fps_n;
  int   tmp_video_fps_d;
  int   tmp_video_par_n;
  int   tmp_video_par_d;
  char *p;
  char *q;
  got_w=got_h=got_interlacing=got_chroma=0;
  got_fps=_avin->video_fps_n>0&&_avin->video_fps_d>0;
  got_par=_avin->video_par_n>=0&&_avin->video_par_d>=0;
  for(p=_tags;;p=q){
    /*Skip any leading spaces.*/
    while(*p==' ')p++;
    /*If that's all we have, stop.*/
    if(p[0]=='\0')break;
    /*Find the end of this tag.*/
    for(q=p+1;*q!='\0'&&*q!=' ';q++);
    /*Process the tag.*/
    switch(p[0]){
      case 'W':{
        if(sscanf(p+1,"%d",&_avin->video_pic_w)!=1)return -1;
        got_w=1;
      }break;
      case 'H':{
        if(sscanf(p+1,"%d",&_avin->video_pic_h)!=1)return -1;
        got_h=1;
      }break;
      case 'F':{
        if(sscanf(p+1,"%d:%d",&tmp_video_fps_n,&tmp_video_fps_d)!=2)return -1;
        got_fps=1;
      }break;
      case 'I':{
        _avin->video_interlacing=p[1];
        got_interlacing=1;
      }break;
      case 'A':{
        if(sscanf(p+1,"%d:%d",&tmp_video_par_n,&tmp_video_par_d)!=2)return -1;
        got_par=1;
      }break;
      case 'C':{
        if(q-p>16)return -1;
        memcpy(_avin->video_chroma_type,p+1,q-p-1);
        _avin->video_chroma_type[q-p-1]='\0';
        got_chroma=1;
      }break;
      /*Ignore unknown tags.*/
    }
  }
  if(!got_w||!got_h||!got_fps||!got_interlacing||!got_par)return -1;
  /*Chroma-type is not specified in older files, e.g., those generated by
     mplayer.*/
  if(!got_chroma)strcpy(_avin->video_chroma_type,"420");
  /*Update fps and aspect ration fields only if not specified on the command
     line.*/
  if(_avin->video_fps_n<=0||_avin->video_fps_d<=0){
    _avin->video_fps_n=tmp_video_fps_n;
    _avin->video_fps_d=tmp_video_fps_d;
  }
  if(_avin->video_par_n<0||_avin->video_par_d<0){
    _avin->video_par_n=tmp_video_par_n;
    _avin->video_par_d=tmp_video_par_d;
  }
  return 0;
}

static void id_y4m_file(av_input *_avin,const char *_file,FILE *_test){
  od_img        *img;
  unsigned char  buf[128];
  int            ret;
  int            pli;
  int            bi;
  for(bi=0;bi<127;bi++){
    ret=fread(buf+bi,1,1,_test);
    if(ret<1)return;
    if(buf[bi]=='\n')break;
  }
  if(bi>=127){
    fprintf(stderr,"Error parsing '%s' header; not a YUV4MPEG2 file?\n",_file);
    exit(1);
  }
  buf[bi]='\0';
  if(memcmp(buf,"MPEG",4))return;
  if(buf[4]!='2'){
    fprintf(stderr,
     "Incorrect YUV input file version; YUV4MPEG2 required.\n");
    exit(1);
  }
  ret=y4m_parse_tags(_avin,(char *)buf+5);
  if(ret<0){
    fprintf(stderr,"Error parsing YUV4MPEG2 header fields in '%s'.\n",_file);
    exit(1);
  }
  if(_avin->video_interlacing!='p'){
    fprintf(stderr,"Interlaced input is not currently supported.\n");
    exit(1);
  }
  _avin->video_infile=_test;
  _avin->has_video=1;
  fprintf(stderr,"File '%s' is %ix%i %0.03f fps %s video.\n",
   _file,_avin->video_pic_w,_avin->video_pic_h,
    (double)_avin->video_fps_n/_avin->video_fps_d,_avin->video_chroma_type);
  /*Allocate buffers for the image data.*/
  /*Pad the frame size to a multiple of 16.*/
  _avin->video_frame_w=_avin->video_pic_w+15&~15;
  _avin->video_frame_h=_avin->video_pic_h+15&~15;
  /*Center the picture region in the frame.
    These will be adjusted based on the chroma sampling type to avoid changing
     how the chroma samples are interpreted.*/
  _avin->video_pic_x=_avin->video_frame_w-_avin->video_pic_w>>1;
  _avin->video_pic_y=_avin->video_frame_h-_avin->video_pic_h>>1;
  /*TODO: Specify chroma offsets.*/
  _avin->video_comps[0].xdec=0;
  _avin->video_comps[0].ydec=0;
  if(strcmp(_avin->video_chroma_type,"444")==0){
    _avin->video_ncomps=3;
    _avin->video_comps[1].xdec=0;
    _avin->video_comps[1].ydec=0;
    _avin->video_comps[2].xdec=0;
    _avin->video_comps[2].ydec=0;
  }
  else if(strcmp(_avin->video_chroma_type,"444alpha")==0){
    _avin->video_ncomps=4;
    _avin->video_comps[1].xdec=0;
    _avin->video_comps[1].ydec=0;
    _avin->video_comps[2].xdec=0;
    _avin->video_comps[2].ydec=0;
    _avin->video_comps[3].xdec=0;
    _avin->video_comps[3].ydec=0;
  }
  else if(strcmp(_avin->video_chroma_type,"422")==0){
    _avin->video_ncomps=3;
    _avin->video_comps[1].xdec=1;
    _avin->video_comps[1].ydec=0;
    _avin->video_comps[2].xdec=1;
    _avin->video_comps[2].ydec=0;
    _avin->video_pic_x&=~1;
  }
  else if(strcmp(_avin->video_chroma_type,"411")==0){
    _avin->video_ncomps=3;
    _avin->video_comps[1].xdec=2;
    _avin->video_comps[1].ydec=0;
    _avin->video_comps[2].xdec=2;
    _avin->video_comps[2].ydec=0;
    _avin->video_pic_x&=~3;
  }
  else if(strcmp(_avin->video_chroma_type,"420")==0||
   strcmp(_avin->video_chroma_type,"420jpeg")==0){
    _avin->video_ncomps=3;
    _avin->video_comps[1].xdec=1;
    _avin->video_comps[1].ydec=1;
    _avin->video_comps[2].xdec=1;
    _avin->video_comps[2].ydec=1;
    _avin->video_pic_x&=~1;
    _avin->video_pic_y&=~1;
  }
  else if(strcmp(_avin->video_chroma_type,"420mpeg2")==0){
    _avin->video_ncomps=3;
    _avin->video_comps[1].xdec=1;
    _avin->video_comps[1].ydec=1;
    _avin->video_comps[2].xdec=1;
    _avin->video_comps[2].ydec=1;
    _avin->video_pic_x&=~1;
    _avin->video_pic_y&=~1;
  }
  else if(strcmp(_avin->video_chroma_type,"420paldv")==0){
    _avin->video_ncomps=3;
    _avin->video_comps[1].xdec=1;
    _avin->video_comps[1].ydec=1;
    _avin->video_comps[2].xdec=1;
    _avin->video_comps[2].ydec=1;
    _avin->video_pic_x&=~1;
    _avin->video_pic_y&=~1;
  }
  else if(strcmp(_avin->video_chroma_type,"mono")==0){
    _avin->video_ncomps=1;
  }
  else{
    fprintf(stderr,"Unknown chroma sampling type: '%s'.\n",
     _avin->video_chroma_type);
    exit(1);
  }
  img=&_avin->video_img;
  img->planes=_avin->video_img_planes;
  img->nplanes=_avin->video_ncomps;
  img->width=_avin->video_frame_w;
  img->height=_avin->video_frame_h;
  for(pli=0;pli<img->nplanes;pli++){
    od_img_plane *iplane;
    iplane=img->planes+pli;
    iplane->xdec=_avin->video_comps[pli].xdec;
    iplane->ydec=_avin->video_comps[pli].ydec;
    iplane->xstride=1;
    iplane->ystride=_avin->video_pic_w+(1<<iplane->xdec)-1>>iplane->xdec;
    iplane->data=_ogg_malloc(iplane->ystride*
     (_avin->video_pic_h+(1<<iplane->ydec)-1>>iplane->ydec));
    /*Shift the origin of the data to correspond to our padding.
      There's no need to actually allocate buffer space for this padding, or to
       fill it in.
      libdaala simply requires that the pointers be set up as if it existed.*/
    iplane->data-=(_avin->video_pic_y>>iplane->ydec)*iplane->ystride+
     (_avin->video_pic_x>>iplane->xdec);
  }
}

static void id_riff_file(av_input *_avin,const char *_file,FILE *_test){
  unsigned char buf[32];
  int           ret;
  ret=fread(buf,1,4,_test);
  ret=fread(buf,1,4,_test);
  if(ret<4)return;
  if(!memcmp(buf,"WAVE",4)){
    while(!feof(_test)){
      ret=fread(buf,1,4,_test);
      if(ret<4)return;
      if(!memcmp("fmt",buf,3)){
        /*This is the audio specs chunk.*/
        ret=fread(buf,1,20,_test);
        if(ret<20)return;
        if(memcmp(buf+4,"\001\000",2)){
          fprintf(stderr,
           "The WAV file '%s' is in a compressed format, and can't be read.\n",
           _file);
          exit(1);
        }
        _avin->audio_infile=_test;
        _avin->audio_ch=buf[6]|buf[7]<<8;
        _avin->audio_hz=buf[8]|buf[9]<<8|buf[10]<<16|buf[11]<<24;
        if((buf[18]|buf[19]<<8)!=16){
          fprintf(stderr,"Can only read 16 bit WAV files.\n");
          exit(1);
        }
        /*Scan until we reach the start of the data chunk.*/
        while(!feof(_test)){
          ret=fread(buf,1,4,_test);
          if(ret<4)return;
          if(!memcmp("data",buf,4)){
            /*Ignore the declared size.*/
            ret=fread(buf,1,4,_test);
            if(ret<4)return;
            fprintf(stderr,
             "File '%s' is 16 bit %i channel %i Hz RIFF WAV audio.\n",
             _file,_avin->audio_ch,_avin->audio_hz);
            _avin->has_audio=1;
            return;
          }
        }
      }
    }
  }
}

static void id_file(av_input *_avin,const char *_file){
  unsigned char  buf[4];
  FILE          *test;
  int            ret;
  if(!strcmp(_file,"-"))test=stdin;
  else{
    test=fopen(_file,"rb");
    if(test==NULL){
      fprintf(stderr,"Unable to open input file '%s'\n",_file);
      exit(1);
    }
  }
  ret=fread(buf,1,4,test);
  if(ret<4){
    fprintf(stderr,"EOF determining file type of file '%s'\n",_file);
    exit(1);
  }
  if(!memcmp(buf,"YUV4",4)){
    if(_avin->has_video){
      fprintf(stderr,
       "Multiple YUV4MPEG2 files specified on the command line.\n");
      exit(1);
    }
    id_y4m_file(_avin,_file,test);
    if(!_avin->has_video){
      fprintf(stderr,"Error parsing YUV4MPEG2 file.\n");
      exit(1);
    }
  }
  else if(!memcmp(buf,"RIFF",4)){
    if(_avin->has_audio){
      fprintf(stderr,
       "Multiple RIFF WAVE files specified on the command line.\n");
      exit(1);
    }
    id_riff_file(_avin,_file,test);
    if(!_avin->has_audio){
      fprintf(stderr,"Error parsing RIFF file, or no WAVE data found.\n");
      exit(1);
    }
  }
  else{
    fprintf(stderr,
     "Input file '%s' is neither a RIFF WAVE or YUV4MPEG2 file.\n",_file);
  }
}

int fetch_and_process_video(av_input *_avin,ogg_page *_page,
 ogg_stream_state *_vo,daala_enc_ctx *_dd,int _video_ready){
  ogg_packet op;
  while(!_video_ready){
    size_t ret;
    char   frame[6];
    char   c;
    int    last;
    if(ogg_stream_pageout(_vo,_page)>0)return 1;
    else if(ogg_stream_eos(_vo))return 0;
    ret=fread(frame,1,6,_avin->video_infile);
    if(ret==6){
      od_img *img;
      int     pli;
      if(memcmp(frame,"FRAME",5)!=0){
        fprintf(stderr,"Loss of framing in YUV input data.\n");
        exit(1);
      }
      if(frame[5]!='\n'){
        int bi;
        for(bi=0;bi<121;bi++){
          if(fread(&c,1,1,_avin->video_infile)==1&&c=='\n')break;
        }
        if(bi>=121){
          fprintf(stderr,"Error parsing YUV frame header.\n");
          exit(1);
        }
      }
      /*Read the frame data.*/
      img=&_avin->video_img;
      for(pli=0;pli<img->nplanes;pli++){
        od_img_plane *iplane;
        size_t        plane_sz;
        iplane=img->planes+pli;
        plane_sz=(_avin->video_pic_w+(1<<iplane->xdec)-1>>iplane->xdec)*
         (_avin->video_pic_h+(1<<iplane->ydec)-1>>iplane->ydec);
        ret=fread(iplane->data+(_avin->video_pic_y>>iplane->ydec)*iplane->ystride+
         (_avin->video_pic_x>>iplane->xdec),1,plane_sz,_avin->video_infile);
        if(ret!=plane_sz){
          fprintf(stderr,"Error reading YUV frame data.\n");
          exit(1);
        }
      }
      last=0;
    }
    else last=1;
    /*Pull the packets from the previous frame, now that we know whether or not
       we can read the current one.
      This is used to set the e_o_s bit on the final packet.*/
    while(daala_encode_packet_out(_dd,last,&op))ogg_stream_packetin(_vo,&op);
    /*Submit the current frame for encoding.*/
    if(!last)daala_encode_img_in(_dd,&_avin->video_img,0);
  }
  return _video_ready;
}

int fetch_and_process_audio(av_input *_avin,ogg_page *_page,
 ogg_stream_state *_ao,vorbis_dsp_state *_vd,vorbis_block *_vb,
 int _audio_ready){
  ogg_packet op;
  while(!_audio_ready){
    char buf[4096];
    int  nread;
    if(ogg_stream_pageout(_ao,_page)>0)return 1;
    else if(ogg_stream_eos(_ao))return 0;
    nread=fread(buf,2*_avin->audio_ch,(sizeof(buf)/(2*_avin->audio_ch)),
     _avin->audio_infile);
    /*Tell the library we're at the end of the stream so that it can handle
       the last frame and mark the end of stream in the output properly.*/
    if(nread<=0)vorbis_analysis_wrote(_vd,0);
    else{
      float **vorbis_buf;
      int     bi;
      int     si;
      int     chi;
      vorbis_buf=vorbis_analysis_buffer(_vd,nread);
      /*Deinterleave samples.*/
      for(si=bi=0;si<nread;si++){
        for(chi=0;chi<_avin->audio_ch;chi++,bi+=2){
          vorbis_buf[chi][si]=(buf[bi+1]<<8|0xFF&buf[bi])*(1.F/32768.F);
        }
      }
      vorbis_analysis_wrote(_vd,nread);
    }
    while(vorbis_analysis_blockout(_vd,_vb)==1){
      /*Analysis, assume we want to use bitrate management.*/
      vorbis_analysis(_vb,NULL);
      vorbis_bitrate_addblock(_vb);
      /*Flush complete packets into the bitstream.*/
      while(vorbis_bitrate_flushpacket(_vd,&op))ogg_stream_packetin(_ao,&op);
    }
  }
  return _audio_ready;
}

static const char *OPTSTRING="o:a:A:v:V:s:S:f:F:h";

static const struct option OPTIONS[]={
  {"output",required_argument,NULL,'o'},
  {"video-quality",required_argument,NULL,'v'},
  {"video-rate-target",required_argument,NULL,'V'},
  {"audio-qualty",required_argument,NULL,'a'},
  {"audio-rate-target",required_argument,NULL,'A'},
  {"aspect-numerator",optional_argument,NULL,'s'},
  {"aspect-denominator",optional_argument,NULL,'S'},
  {"framerate-numerator",optional_argument,NULL,'f'},
  {"framerate-denominator",optional_argument,NULL,'F'},
  {"help",no_argument,NULL,'h'},
  {NULL,0,NULL,0}
};

static void usage(void){
  fprintf(stderr,
   "Usage: encoder_example [options] [audio_file] video_file\n\n"
   "Options:\n\n"
   "  -o --output <filename.ogg>     file name for encoded output;\n"
   "                                 If this option is not given, the\n"
   "                                 compressed data is sent to stdout.\n\n"
   "  -v --video-quality <n>         Daala quality selector from 0 to 10.\n"
   "                                 0 yields the smallest files, but\n"
   "                                 lowest video quality; 10 yields the\n"
   "                                 highest quality, but large files.\n\n"
   "  -V --video-rate-target <n>     bitrate target for Daala video;\n"
   "                                 use -v and not -V if at all possible,\n"
   "                                 as -v gives higher quality for a given\n"
   "                                 bitrate.\n\n"
   "  -a --audio-quality <n>         Vorbis quality selector from -1 to 10.\n"
   "                                 -1 yields the smallest files, but\n"
   "                                 lowest fidelity; 10 yields the highest\n"
   "                                 fidelity, but large files. 2 is a\n"
   "                                 reasonable default.\n\n"
   "  -A --audio-rate-target <n>     bitrate target for Vorbis audio;\n"
   "                                 use -a and not -A if at all possible,\n"
   "                                 as -a gives higher quality for a given\n"
   "                                 bitrate.\n\n"
   "encoder_example accepts only uncompressed RIFF WAV format audio and\n"
   "uncompressed YUV4MPEG2 video.\n\n");
  exit(1);
}

int main(int _argc,char **_argv){
  FILE             *outfile;
  av_input          avin;
  ogg_stream_state  vo;
  ogg_stream_state  ao;
  ogg_page          og;
  ogg_packet        op;
  daala_enc_ctx    *dd;
  daala_info        di;
  daala_comment     dc;
  vorbis_dsp_state  vd;
  vorbis_block      vb;
  vorbis_info       vi;
  vorbis_comment    vc;
  ogg_int64_t       video_bytesout;
  ogg_int64_t       audio_bytesout;
  double            time_base;
  int               c;
  int               loi;
  int               ret;
  int               video_kbps;
  int               audio_kbps;
  int               video_q;
  float             audio_q;
  int               video_r;
  int               audio_r;
  int               video_ready;
  int               audio_ready;
#if defined(_WIN32)
  _setmode(_fileno(stdin),_O_BINARY);
  _setmode(_fileno(stdout),_O_BINARY);
#endif
  outfile=stdout;
  memset(&avin,0,sizeof(avin));
  avin.video_fps_n=-1;
  avin.video_fps_d=-1;
  avin.video_par_n=-1;
  avin.video_par_d=-1;
  video_q=48;
  video_r=-1;
  audio_q=0.1F;
  audio_r=-1;
  video_bytesout=0;
  audio_bytesout=0;
  video_kbps=0;
  audio_kbps=0;
  while((c=getopt_long(_argc,_argv,OPTSTRING,OPTIONS,&loi))!=EOF){
    switch(c){
      case 'o':{
        outfile=fopen(optarg,"wb");
        if(outfile==NULL){
          fprintf(stderr,"Unable to open output file '%s'\n",optarg);
          exit(1);
        }
      }break;
      case 'v':{
        video_q=(int)rint(atof(optarg)*6.3);
        if(video_q<0||video_q>63){
          fprintf(stderr,"Illegal video quality (use 0 through 10)\n");
          exit(1);
        }
        video_r=0;
      }break;
      case 'V':{
        video_r=(int)rint(atof(optarg)*1000);
        if(video_r<45000||video_r>2000000){
          fprintf(stderr,
           "Illegal video bitrate (use 45kbps through 2000kbps)\n");
          exit(1);
        }
        video_q=0;
      }break;
      case 'a':{
        audio_q=(float)(atof(optarg)*0.99);
        if(audio_q<-.1||audio_q>1){
          fprintf(stderr,"Illegal audio qualty (use -1 through 10)\n");
          exit(1);
        }
        audio_r=-1;
      }break;
      case 'A':{
        audio_r=(int)rint(atof(optarg)*1000);
        if(audio_r<0){
          fprintf(stderr,"Illegal audio rate (use a value >= 0)\n");
          exit(1);
        }
        audio_q=-99;
      }break;
      case 'h':
      default:{
        usage();
      }
    }
  }
  /*Assume anything following the options must be a file name.*/
  for(;optind<_argc;optind++)id_file(&avin,_argv[optind]);
  srand(time(NULL));
  ogg_stream_init(&vo,rand());
  ogg_stream_init(&ao,rand());
  if(!avin.has_video){
    fprintf(stderr,"No video files submitted for compression.\n");
    exit(1);
  }
  if(avin.has_video){
    daala_info_init(&di);
    di.frame_width=avin.video_frame_w;
    di.frame_height=avin.video_frame_h;
    di.pic_x=avin.video_pic_x;
    di.pic_y=avin.video_pic_y;
    di.pic_width=avin.video_pic_w;
    di.pic_height=avin.video_pic_h;
    di.timebase_numerator=avin.video_fps_n;
    di.timebase_denominator=avin.video_fps_d;
    di.frame_duration=1;
    di.pixel_aspect_numerator=avin.video_par_n;
    di.pixel_aspect_denominator=avin.video_par_d;
    di.ncomps=avin.video_ncomps;
    di.comps=avin.video_comps;
    /*TODO: Other crap.*/
    dd=daala_encode_alloc(&di);
    daala_info_clear(&di);
    daala_comment_init(&dc);
    /*TODO: Set up encoder.*/
  }
  if(avin.has_audio){
    vorbis_info_init(&vi);
    if(audio_q>-99){
      ret=vorbis_encode_init_vbr(&vi,avin.audio_ch,avin.audio_hz,audio_q);
    }
    else ret=vorbis_encode_init(&vi,avin.audio_ch,avin.audio_hz,-1,audio_r,-1);
    if(ret){
      fprintf(stderr,
       "The Vorbis encoder could not set up a mode according to\n"
       "the requested quality or bitrate.\n");
      exit(1);
    }
    vorbis_comment_init(&vc);
    vorbis_analysis_init(&vd,&vi);
    vorbis_block_init(&vd,&vb);
  }
  /*Write the bitstream header packets with proper page interleave.*/
  /*The first packet for each logical stream will get its own page
     automatically.*/
  if(avin.has_video){
    if(daala_encode_flush_header(dd,&dc,&op)<=0){
      fprintf(stderr,"Internal Daala library error.\n");
      exit(1);
    }
    ogg_stream_packetin(&vo,&op);
    if(ogg_stream_pageout(&vo,&og)!=1){
      fprintf(stderr,"Internal Ogg library error.\n");
      exit(1);
    }
    fwrite(og.header,1,og.header_len,outfile);
    fwrite(og.body,1,og.body_len,outfile);
    /*Create and buffer the remaining Daala headers.*/
    for(;;){
      ret=daala_encode_flush_header(dd,&dc,&op);
      if(ret<0){
        fprintf(stderr,"Internal Daala library error.\n");
        exit(1);
      }
      else if(!ret)break;
      ogg_stream_packetin(&vo,&op);
    }
  }
  if(avin.has_audio){
    ogg_packet header;
    ogg_packet header_comm;
    ogg_packet header_code;
    vorbis_analysis_headerout(&vd,&vc,&header,&header_comm,&header_code);
    ogg_stream_packetin(&ao,&header);
    if(ogg_stream_pageout(&ao,&og)!=1){
      fprintf(stderr,"Internal Ogg library error.\n");
      exit(1);
    }
    fwrite(og.header,1,og.header_len,outfile);
    fwrite(og.body,1,og.body_len,outfile);
    /*Buffer the remaining Vorbis header packets.*/
    ogg_stream_packetin(&ao,&header_comm);
    ogg_stream_packetin(&ao,&header_code);
  }
  if(avin.has_video){
    for(;;){
      ret=ogg_stream_flush(&vo,&og);
      if(ret<0){
        fprintf(stderr,"Internal Ogg library error.\n");
        exit(1);
      }
      else if(!ret)break;
      fwrite(og.header,1,og.header_len,outfile);
      fwrite(og.body,1,og.body_len,outfile);
    }
  }
  if(avin.has_audio){
    for(;;){
      ret=ogg_stream_flush(&ao,&og);
      if(ret<0){
        fprintf(stderr,"Internal Ogg library error.\n");
        exit(1);
      }
      else if(!ret)break;
      fwrite(og.header,1,og.header_len,outfile);
      fwrite(og.body,1,og.body_len,outfile);
    }
  }
  /*Setup complete.
    Main compression loop.*/
  fprintf(stderr,"Compressing...\n");
  audio_ready=video_ready=0;
  for(;;){
    ogg_page audio_page;
    ogg_page video_page;
    double   audio_time;
    double   video_time;
    if(avin.has_video){
      video_ready=fetch_and_process_video(&avin,&video_page,
       &vo,dd,video_ready);
    }
    if(avin.has_audio){
      audio_ready=fetch_and_process_audio(&avin,&audio_page,
       &ao,&vd,&vb,audio_ready);
    }
    /*TODO: Fetch the next video page.*/
    /*If no more pages are available, we've hit the end of the stream.*/
    if(!video_ready&&!audio_ready)break;
    video_time=video_ready?
     daala_granule_time(dd,ogg_page_granulepos(&video_page)):-1;
    audio_time=audio_ready?
     vorbis_granule_time(&vd,ogg_page_granulepos(&audio_page)):-1;
    if(!audio_ready||video_time<audio_time){
      video_bytesout+=
       fwrite(video_page.header,1,video_page.header_len,outfile);
      video_bytesout+=fwrite(video_page.body,1,video_page.body_len,outfile);
      video_ready=0;
      video_kbps=(int)rint(video_bytesout*8*0.001/video_time);
      time_base=video_time;
    }
    else{
      audio_bytesout+=
       fwrite(audio_page.header,1,audio_page.header_len,outfile);
      audio_bytesout+=fwrite(audio_page.body,1,audio_page.body_len,outfile);
      audio_ready=0;
      audio_kbps=(int)rint(audio_bytesout*8*0.001/audio_time);
      time_base=audio_time;
    }
    fprintf(stderr,
     "\r     %i:%02i:%02i.%02i audio %ikbps video: %ikbps          ",
     (int)time_base/3600,((int)time_base/60)%60,(int)time_base%60,
     (int)(time_base*100-(long)time_base*100),audio_kbps,video_kbps);
  }
  if(avin.has_audio){
    ogg_stream_clear(&ao);
    vorbis_block_clear(&vb);
    vorbis_dsp_clear(&vd);
    vorbis_comment_clear(&vc);
    vorbis_info_clear(&vi);
  }
  if(avin.has_video){
    ogg_stream_clear(&vo);
    daala_encode_free(dd);
    daala_comment_clear(&dc);
  }
  if(outfile!=NULL&&outfile!=stdout)fclose(outfile);
  fprintf(stderr,"\r    \ndone.\n\r");
  return 0;
}
